{"filter":false,"title":"dictionary.c","tooltip":"/pset5/speller/dictionary.c","undoManager":{"mark":17,"position":17,"stack":[[{"start":{"row":0,"column":0},"end":{"row":54,"column":0},"action":"remove","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1];","    struct node *next;","}","node;","","// Number of buckets in hash table","const unsigned int N = 1;","","// Hash table","node *table[N];","","// Returns true if word is in dictionary else false","bool check(const char *word)","{","    // TODO","    return false;","}","","// Hashes word to a number","unsigned int hash(const char *word)","{","    // TODO","    return 0;","}","","// Loads dictionary into memory, returning true if successful else false","bool load(const char *dictionary)","{","    // TODO","    return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void)","{","    // TODO","    return 0;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void)","{","    // TODO","    return false;","}",""],"id":2},{"start":{"row":0,"column":0},"end":{"row":158,"column":1},"action":"insert","lines":["// Implements a dictionary's functionality","#include <ctype.h>","#include <stdbool.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <strings.h>","","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1];","    struct node *next;","}","node;","","// Number of buckets in hash table","const unsigned int N = 26;","","// Initiate hash_value","// Unsigned int for positive values","unsigned int hash_value;","","// Initialize number of words in hash table","unsigned int word_count;","","// Hash table","node *table[N];","","// Returns true if word is in dictionary else false","bool check(const char *word)","{","    // Hash the word to get hash value","    hash_value = hash(word);","    // Access linked list at hash_value index in the hash table","    node *cursor = table[hash_value];","","    // Traverse linked list","    while (cursor != NULL)","    {","        // If the word is in the dictionnary","        // strcasecmp: is case-insensitive","        if (strcasecmp(word, cursor->word) == 0)","        {","            return true;","        }","","        // Set cursor to next item","        cursor = cursor->next;","    }","    return false;","}","","// Hashes word to a number","unsigned int hash(const char *word)","{","    // http://www.cse.yorku.ca/~oz/hash.html","    unsigned long hash = 5381;","    int c;","    while ((c = tolower(*word++)))","    {","        // << is the left shift operator","        // http://www.fredosaurus.com/notes-cpp/expressions/bitops.html","        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */","    }","    return hash % N;","}","","// Loads dictionary into memory, returning true if successful else false","bool load(const char *dictionary)","{","    // Open dictionary as file","    FILE *file = fopen(dictionary, \"r\");","","    // If no file, return false","    if (file == NULL)","    {","        return false;","    }","","    // Buffer space for word","    char word[LENGTH + 1];","","    // Scan file for strings until fscanf returns EOF","    while (fscanf(file, \"%s\", word) != EOF)","    {","        // Allocate memory for new node","        node *n = malloc(sizeof(node));","","        // If malloc returns NULL, return false","        if (n == NULL)","        {","            return false;","        }","","        // Pointer to next node and word itself","        strcpy(n->word, word);","        // Hash the word to get hash value","        hash_value = hash(word);","        // Set new pointer","        n->next = table[hash_value];","        // Set head to new pointer","        table[hash_value] = n;","        // Increase word_count by 1 on every entry","        word_count++;","    }","","    // Close file","    fclose(file);","","    // Dictionnary is loaded, return true","    return true;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void)","{","    // Check if word_count is bigger than 0","    if (word_count > 0)","    {","        // Return number of words","        return word_count;","    }","    // Otherwise, return 0","    return 0;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void)","{","    // Iterate over every bunker","    for (int i = 0; i < N; i++)","    {","        // Set cursor to this bunker's location in the table","        node *cursor = table[i];","","        // Free cursor if not NULL","        while (cursor)","        {","            // Swap: set dummy variable tmp to be equal to cursor","            // Using tmp: don't wanna lose access to the rest of the nodes","            node *tmp = cursor;","            // Set cursor to next item","            cursor = cursor->next;","            // Free temp","            free(tmp);","        }","","        // If last bunker in table and cursor is NULL","        if (i == N - 1 && cursor == NULL)","        {","            // Is successful, return true","            return true;","        }","    }","    return false;","}"]}],[{"start":{"row":152,"column":7},"end":{"row":152,"column":8},"action":"insert","lines":[" "],"id":4}],[{"start":{"row":154,"column":0},"end":{"row":154,"column":12},"action":"remove","lines":["            "],"id":5},{"start":{"row":154,"column":0},"end":{"row":154,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":154,"column":4},"end":{"row":154,"column":8},"action":"insert","lines":["    "],"id":6}],[{"start":{"row":154,"column":8},"end":{"row":154,"column":12},"action":"insert","lines":["    "],"id":7}],[{"start":{"row":154,"column":12},"end":{"row":154,"column":16},"action":"insert","lines":["    "],"id":8}],[{"start":{"row":154,"column":16},"end":{"row":154,"column":20},"action":"insert","lines":["    "],"id":9}],[{"start":{"row":154,"column":20},"end":{"row":154,"column":24},"action":"insert","lines":["    "],"id":10}],[{"start":{"row":154,"column":24},"end":{"row":154,"column":28},"action":"insert","lines":["    "],"id":11}],[{"start":{"row":146,"column":11},"end":{"row":146,"column":12},"action":"insert","lines":[" "],"id":12}],[{"start":{"row":146,"column":12},"end":{"row":146,"column":16},"action":"insert","lines":["    "],"id":13}],[{"start":{"row":146,"column":16},"end":{"row":146,"column":20},"action":"insert","lines":["    "],"id":14}],[{"start":{"row":143,"column":11},"end":{"row":143,"column":12},"action":"insert","lines":[" "],"id":15}],[{"start":{"row":143,"column":12},"end":{"row":143,"column":16},"action":"insert","lines":["    "],"id":16}],[{"start":{"row":143,"column":16},"end":{"row":143,"column":20},"action":"insert","lines":["    "],"id":17}],[{"start":{"row":143,"column":20},"end":{"row":143,"column":24},"action":"insert","lines":["    "],"id":18}],[{"start":{"row":143,"column":24},"end":{"row":143,"column":28},"action":"insert","lines":["    "],"id":19}],[{"start":{"row":143,"column":28},"end":{"row":143,"column":32},"action":"insert","lines":["    "],"id":20}]]},"ace":{"folds":[],"scrolltop":2263,"scrollleft":0,"selection":{"start":{"row":143,"column":32},"end":{"row":143,"column":32},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1592007597075,"hash":"0cf6e3a7cc0b63eb0cd308c89132582382702271"}